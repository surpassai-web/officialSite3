/* Polyfill service v3.108.0
 * For detailed credits and licence information see https://github.com/financial-times/polyfill-service.
 * 
 * Features requested: Array.prototype.filter,Array.prototype.find,Array.prototype.map,Array.prototype.some,Array.prototype.sort,String.prototype.startsWith
 * 
 * - _ESAbstract.ArrayCreate, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate")
 * - _ESAbstract.Call, License: CC0 (required by "String.prototype.startsWith", "_ESAbstract.ToString", "_ESAbstract.ToPrimitive", "_ESAbstract.OrdinaryToPrimitive")
 * - _ESAbstract.Get, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties")
 * - _ESAbstract.HasOwnProperty, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties", "Object.getOwnPropertyDescriptor")
 * - _ESAbstract.HasProperty, License: CC0 (required by "Array.prototype.some")
 * - _ESAbstract.IsArray, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate")
 * - _ESAbstract.IsCallable, License: CC0 (required by "String.prototype.startsWith", "_ESAbstract.ToString", "_ESAbstract.ToPrimitive", "_ESAbstract.OrdinaryToPrimitive")
 * - _ESAbstract.RequireObjectCoercible, License: CC0 (required by "String.prototype.startsWith")
 * - _ESAbstract.ToBoolean, License: CC0 (required by "String.prototype.startsWith", "_ESAbstract.IsRegExp")
 * - _ESAbstract.ToObject, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties", "Object.getOwnPropertyDescriptor")
 * - _ESAbstract.GetV, License: CC0 (required by "String.prototype.startsWith", "_ESAbstract.ToString", "_ESAbstract.ToPrimitive", "_ESAbstract.GetMethod")
 * - _ESAbstract.GetMethod, License: CC0 (required by "String.prototype.startsWith", "_ESAbstract.ToString", "_ESAbstract.ToPrimitive")
 * - _ESAbstract.Type, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties", "Object.getOwnPropertyDescriptor", "_ESAbstract.ToPropertyKey")
 * - _ESAbstract.GetPrototypeFromConstructor, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor")
 * - _ESAbstract.IsConstructor, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct")
 * - _ESAbstract.IsRegExp, License: CC0 (required by "String.prototype.startsWith")
 * - _ESAbstract.OrdinaryToPrimitive, License: CC0 (required by "String.prototype.startsWith", "_ESAbstract.ToString", "_ESAbstract.ToPrimitive")
 * - _ESAbstract.ToInteger, License: CC0 (required by "Array.prototype.some", "_ESAbstract.ToLength")
 * - _ESAbstract.ToLength, License: CC0 (required by "Array.prototype.some")
 * - _ESAbstract.ToPrimitive, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties", "Object.getOwnPropertyDescriptor", "_ESAbstract.ToPropertyKey")
 * - _ESAbstract.ToString, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties", "Object.getOwnPropertyDescriptor", "_ESAbstract.ToPropertyKey")
 * - _ESAbstract.ToPropertyKey, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties", "Object.getOwnPropertyDescriptor")
 * - Object.defineProperty, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties")
 * - _ESAbstract.CreateDataProperty, License: CC0 (required by "Array.prototype.map", "_ESAbstract.CreateDataPropertyOrThrow")
 * - _ESAbstract.CreateDataPropertyOrThrow, License: CC0 (required by "Array.prototype.map")
 * - _ESAbstract.CreateMethodProperty, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties", "Object.getOwnPropertyDescriptor")
 * - Array.prototype.find, License: CC0
 * - Array.prototype.some, License: CC0
 * - Function.prototype.bind, License: MIT (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties", "Object.getOwnPropertyDescriptor")
 * - Object.getOwnPropertyDescriptor, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties")
 * - Object.getPrototypeOf, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor")
 * - Object.keys, License: MIT (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create", "Object.defineProperties")
 * - Object.defineProperties, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor", "Object.create")
 * - Object.create, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct", "_ESAbstract.OrdinaryCreateFromConstructor")
 * - _ESAbstract.OrdinaryCreateFromConstructor, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate", "_ESAbstract.Construct")
 * - _ESAbstract.Construct, License: CC0 (required by "Array.prototype.map", "_ESAbstract.ArraySpeciesCreate")
 * - _ESAbstract.ArraySpeciesCreate, License: CC0 (required by "Array.prototype.map")
 * - Array.prototype.filter, License: CC0
 * - Array.prototype.map, License: CC0 (required by "Array.prototype.sort")
 * - Array.prototype.sort, License: MIT
 * - String.prototype.startsWith, License: CC0 */

(function (self, undefined) {

	// _ESAbstract.ArrayCreate
	// 9.4.2.2. ArrayCreate ( length [ , proto ] )
	function ArrayCreate(length /* [, proto] */) { // eslint-disable-line no-unused-vars
		// 1. Assert: length is an integer Number ≥ 0.
		// 2. If length is -0, set length to +0.
		if (1 / length === -Infinity) {
			length = 0;
		}
		// 3. If length>2^32-1, throw a RangeError exception.
		if (length > (Math.pow(2, 32) - 1)) {
			throw new RangeError('Invalid array length');
		}
		// 4. If proto is not present, set proto to the intrinsic object %ArrayPrototype%.
		// 5. Let A be a newly created Array exotic object.
		var A = [];
		// 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1.
		// 7. Set A.[[DefineOwnProperty]] as specified in 9.4.2.1.
		// 8. Set A.[[Prototype]] to proto.
		// 9. Set A.[[Extensible]] to true.
		// 10. Perform ! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor{[[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).
		A.length = length;
		// 11. Return A.
		return A;
	}

	// _ESAbstract.Call
	/* global IsCallable */
	// 7.3.12. Call ( F, V [ , argumentsList ] )
	function Call(F, V /* [, argumentsList] */) { // eslint-disable-line no-unused-vars
		// 1. If argumentsList is not present, set argumentsList to a new empty List.
		var argumentsList = arguments.length > 2 ? arguments[2] : [];
		// 2. If IsCallable(F) is false, throw a TypeError exception.
		if (IsCallable(F) === false) {
			throw new TypeError(Object.prototype.toString.call(F) + 'is not a function.');
		}
		// 3. Return ? F.[[Call]](V, argumentsList).
		return F.apply(V, argumentsList);
	}

	// _ESAbstract.Get
	// 7.3.1. Get ( O, P )
	function Get(O, P) { // eslint-disable-line no-unused-vars
		// 1. Assert: Type(O) is Object.
		// 2. Assert: IsPropertyKey(P) is true.
		// 3. Return ? O.[[Get]](P, O).
		return O[P];
	}

	// _ESAbstract.HasOwnProperty
	// 7.3.11 HasOwnProperty (O, P)
	function HasOwnProperty(o, p) { // eslint-disable-line no-unused-vars
		// 1. Assert: Type(O) is Object.
		// 2. Assert: IsPropertyKey(P) is true.
		// 3. Let desc be ? O.[[GetOwnProperty]](P).
		// 4. If desc is undefined, return false.
		// 5. Return true.
		// Polyfill.io - As we expect user agents to support ES3 fully we can skip the above steps and use Object.prototype.hasOwnProperty to do them for us.
		return Object.prototype.hasOwnProperty.call(o, p);
	}

	// _ESAbstract.HasProperty
	// 7.3.10. HasProperty ( O, P )
	function HasProperty(O, P) { // eslint-disable-line no-unused-vars
		// Assert: Type(O) is Object.
		// Assert: IsPropertyKey(P) is true.
		// Return ? O.[[HasProperty]](P).
		return P in O;
	}

	// _ESAbstract.IsArray
	// 7.2.2. IsArray ( argument )
	function IsArray(argument) { // eslint-disable-line no-unused-vars
		// 1. If Type(argument) is not Object, return false.
		// 2. If argument is an Array exotic object, return true.
		// 3. If argument is a Proxy exotic object, then
		// a. If argument.[[ProxyHandler]] is null, throw a TypeError exception.
		// b. Let target be argument.[[ProxyTarget]].
		// c. Return ? IsArray(target).
		// 4. Return false.

		// Polyfill.io - We can skip all the above steps and check the string returned from Object.prototype.toString().
		return Object.prototype.toString.call(argument) === '[object Array]';
	}

	// _ESAbstract.IsCallable
	// 7.2.3. IsCallable ( argument )
	function IsCallable(argument) { // eslint-disable-line no-unused-vars
		// 1. If Type(argument) is not Object, return false.
		// 2. If argument has a [[Call]] internal method, return true.
		// 3. Return false.

		// Polyfill.io - Only function objects have a [[Call]] internal method. This means we can simplify this function to check that the argument has a type of function.
		return typeof argument === 'function';
	}

	// _ESAbstract.RequireObjectCoercible
	// 7.2.1. RequireObjectCoercible ( argument )
	// The abstract operation ToObject converts argument to a value of type Object according to Table 12:
	// Table 12: ToObject Conversions
	/*
	|----------------------------------------------------------------------------------------------------------------------------------------------------|
	| Argument Type | Result                                                                                                                             |
	|----------------------------------------------------------------------------------------------------------------------------------------------------|
	| Undefined     | Throw a TypeError exception.                                                                                                       |
	| Null          | Throw a TypeError exception.                                                                                                       |
	| Boolean       | Return argument.                                                                                                                   |
	| Number        | Return argument.                                                                                                                   |
	| String        | Return argument.                                                                                                                   |
	| Symbol        | Return argument.                                                                                                                   |
	| Object        | Return argument.                                                                                                                   |
	|----------------------------------------------------------------------------------------------------------------------------------------------------|
	*/
	function RequireObjectCoercible(argument) { // eslint-disable-line no-unused-vars
		if (argument === null || argument === undefined) {
			throw TypeError(Object.prototype.toString.call(argument) + ' is not coercible to Object.');
		}
		return argument;
	}

	// _ESAbstract.ToBoolean
	// 7.1.2. ToBoolean ( argument )
	// The abstract operation ToBoolean converts argument to a value of type Boolean according to Table 9:
	/*
	--------------------------------------------------------------------------------------------------------------
	| Argument Type | Result                                                                                     |
	--------------------------------------------------------------------------------------------------------------
	| Undefined     | Return false.                                                                              |
	| Null          | Return false.                                                                              |
	| Boolean       | Return argument.                                                                           |
	| Number        | If argument is +0, -0, or NaN, return false; otherwise return true.                        |
	| String        | If argument is the empty String (its length is zero), return false; otherwise return true. |
	| Symbol        | Return true.                                                                               |
	| Object        | Return true.                                                                               |
	--------------------------------------------------------------------------------------------------------------
	*/
	function ToBoolean(argument) { // eslint-disable-line no-unused-vars
		return Boolean(argument);
	}

	// _ESAbstract.ToObject
	// 7.1.13 ToObject ( argument )
	// The abstract operation ToObject converts argument to a value of type Object according to Table 12:
	// Table 12: ToObject Conversions
	/*
	|----------------------------------------------------------------------------------------------------------------------------------------------------|
	| Argument Type | Result                                                                                                                             |
	|----------------------------------------------------------------------------------------------------------------------------------------------------|
	| Undefined     | Throw a TypeError exception.                                                                                                       |
	| Null          | Throw a TypeError exception.                                                                                                       |
	| Boolean       | Return a new Boolean object whose [[BooleanData]] internal slot is set to argument. See 19.3 for a description of Boolean objects. |
	| Number        | Return a new Number object whose [[NumberData]] internal slot is set to argument. See 20.1 for a description of Number objects.    |
	| String        | Return a new String object whose [[StringData]] internal slot is set to argument. See 21.1 for a description of String objects.    |
	| Symbol        | Return a new Symbol object whose [[SymbolData]] internal slot is set to argument. See 19.4 for a description of Symbol objects.    |
	| Object        | Return argument.                                                                                                                   |
	|----------------------------------------------------------------------------------------------------------------------------------------------------|
	*/
	function ToObject(argument) { // eslint-disable-line no-unused-vars
		if (argument === null || argument === undefined) {
			throw TypeError();
		}
		return Object(argument);
	}

	// _ESAbstract.GetV
	/* global ToObject */
	// 7.3.2 GetV (V, P)
	function GetV(v, p) { // eslint-disable-line no-unused-vars
		// 1. Assert: IsPropertyKey(P) is true.
		// 2. Let O be ? ToObject(V).
		var o = ToObject(v);
		// 3. Return ? O.[[Get]](P, V).
		return o[p];
	}

	// _ESAbstract.GetMethod
	/* global GetV, IsCallable */
	// 7.3.9. GetMethod ( V, P )
	function GetMethod(V, P) { // eslint-disable-line no-unused-vars
		// 1. Assert: IsPropertyKey(P) is true.
		// 2. Let func be ? GetV(V, P).
		var func = GetV(V, P);
		// 3. If func is either undefined or null, return undefined.
		if (func === null || func === undefined) {
			return undefined;
		}
		// 4. If IsCallable(func) is false, throw a TypeError exception.
		if (IsCallable(func) === false) {
			throw new TypeError('Method not callable: ' + P);
		}
		// 5. Return func.
		return func;
	}

	// _ESAbstract.Type
	// "Type(x)" is used as shorthand for "the type of x"...
	function Type(x) { // eslint-disable-line no-unused-vars
		switch (typeof x) {
			case 'undefined':
				return 'undefined';
			case 'boolean':
				return 'boolean';
			case 'number':
				return 'number';
			case 'string':
				return 'string';
			case 'symbol':
				return 'symbol';
			default:
				// typeof null is 'object'
				if (x === null) return 'null';
				// Polyfill.io - This is here because a Symbol polyfill will have a typeof `object`.
				if ('Symbol' in self && (x instanceof self.Symbol || x.constructor === self.Symbol)) return 'symbol';

				return 'object';
		}
	}

	// _ESAbstract.GetPrototypeFromConstructor
	/* global Get, Type */
	// 9.1.14. GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )
	function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) { // eslint-disable-line no-unused-vars
		// 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.
		// 2. Assert: IsCallable(constructor) is true.
		// 3. Let proto be ? Get(constructor, "prototype").
		var proto = Get(constructor, "prototype");
		// 4. If Type(proto) is not Object, then
		if (Type(proto) !== 'object') {
			// a. Let realm be ? GetFunctionRealm(constructor).
			// b. Set proto to realm's intrinsic object named intrinsicDefaultProto.
			proto = intrinsicDefaultProto;
		}
		// 5. Return proto.
		return proto;
	}

	// _ESAbstract.IsConstructor
	/* global Type */
	// 7.2.4. IsConstructor ( argument )
	function IsConstructor(argument) { // eslint-disable-line no-unused-vars
		// 1. If Type(argument) is not Object, return false.
		if (Type(argument) !== 'object') {
			return false;
		}
		// 2. If argument has a [[Construct]] internal method, return true.
		// 3. Return false.

		// Polyfill.io - `new argument` is the only way  to truly test if a function is a constructor.
		// We choose to not use`new argument` because the argument could have side effects when called.
		// Instead we check to see if the argument is a function and if it has a prototype.
		// Arrow functions do not have a [[Construct]] internal method, nor do they have a prototype.
		return typeof argument === 'function' && !!argument.prototype;
	}

	// _ESAbstract.IsRegExp
	/* global Type, Get, ToBoolean */
	// 7.2.8. IsRegExp ( argument )
	function IsRegExp(argument) { // eslint-disable-line no-unused-vars
		// 1. If Type(argument) is not Object, return false.
		if (Type(argument) !== 'object') {
			return false;
		}
		// 2. Let matcher be ? Get(argument, @@match).
		var matcher = 'Symbol' in self && 'match' in self.Symbol ? Get(argument, self.Symbol.match) : undefined;
		// 3. If matcher is not undefined, return ToBoolean(matcher).
		if (matcher !== undefined) {
			return ToBoolean(matcher);
		}
		// 4. If argument has a [[RegExpMatcher]] internal slot, return true.
		try {
			var lastIndex = argument.lastIndex;
			argument.lastIndex = 0;
			RegExp.prototype.exec.call(argument);
			return true;
			// eslint-disable-next-line no-empty
		} catch (e) { } finally {
			argument.lastIndex = lastIndex;
		}
		// 5. Return false.
		return false;
	}

	// _ESAbstract.OrdinaryToPrimitive
	/* global Get, IsCallable, Call, Type */
	// 7.1.1.1. OrdinaryToPrimitive ( O, hint )
	function OrdinaryToPrimitive(O, hint) { // eslint-disable-line no-unused-vars
		// 1. Assert: Type(O) is Object.
		// 2. Assert: Type(hint) is String and its value is either "string" or "number".
		// 3. If hint is "string", then
		if (hint === 'string') {
			// a. Let methodNames be « "toString", "valueOf" ».
			var methodNames = ['toString', 'valueOf'];
			// 4. Else,
		} else {
			// a. Let methodNames be « "valueOf", "toString" ».
			methodNames = ['valueOf', 'toString'];
		}
		// 5. For each name in methodNames in List order, do
		for (var i = 0; i < methodNames.length; ++i) {
			var name = methodNames[i];
			// a. Let method be ? Get(O, name).
			var method = Get(O, name);
			// b. If IsCallable(method) is true, then
			if (IsCallable(method)) {
				// i. Let result be ? Call(method, O).
				var result = Call(method, O);
				// ii. If Type(result) is not Object, return result.
				if (Type(result) !== 'object') {
					return result;
				}
			}
		}
		// 6. Throw a TypeError exception.
		throw new TypeError('Cannot convert to primitive.');
	}

	// _ESAbstract.ToInteger
	/* global Type */
	// 7.1.4. ToInteger ( argument )
	function ToInteger(argument) { // eslint-disable-line no-unused-vars
		if (Type(argument) === 'symbol') {
			throw new TypeError('Cannot convert a Symbol value to a number');
		}

		// 1. Let number be ? ToNumber(argument).
		var number = Number(argument);
		// 2. If number is NaN, return +0.
		if (isNaN(number)) {
			return 0;
		}
		// 3. If number is +0, -0, +∞, or -∞, return number.
		if (1 / number === Infinity || 1 / number === -Infinity || number === Infinity || number === -Infinity) {
			return number;
		}
		// 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).
		return ((number < 0) ? -1 : 1) * Math.floor(Math.abs(number));
	}

	// _ESAbstract.ToLength
	/* global ToInteger */
	// 7.1.15. ToLength ( argument )
	function ToLength(argument) { // eslint-disable-line no-unused-vars
		// 1. Let len be ? ToInteger(argument).
		var len = ToInteger(argument);
		// 2. If len ≤ +0, return +0.
		if (len <= 0) {
			return 0;
		}
		// 3. Return min(len, 253-1).
		return Math.min(len, Math.pow(2, 53) - 1);
	}

	// _ESAbstract.ToPrimitive
	/* global Type, GetMethod, Call, OrdinaryToPrimitive */
	// 7.1.1. ToPrimitive ( input [ , PreferredType ] )
	function ToPrimitive(input /* [, PreferredType] */) { // eslint-disable-line no-unused-vars
		var PreferredType = arguments.length > 1 ? arguments[1] : undefined;
		// 1. Assert: input is an ECMAScript language value.
		// 2. If Type(input) is Object, then
		if (Type(input) === 'object') {
			// a. If PreferredType is not present, let hint be "default".
			if (arguments.length < 2) {
				var hint = 'default';
				// b. Else if PreferredType is hint String, let hint be "string".
			} else if (PreferredType === String) {
				hint = 'string';
				// c. Else PreferredType is hint Number, let hint be "number".
			} else if (PreferredType === Number) {
				hint = 'number';
			}
			// d. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).
			var exoticToPrim = typeof self.Symbol === 'function' && typeof self.Symbol.toPrimitive === 'symbol' ? GetMethod(input, self.Symbol.toPrimitive) : undefined;
			// e. If exoticToPrim is not undefined, then
			if (exoticToPrim !== undefined) {
				// i. Let result be ? Call(exoticToPrim, input, « hint »).
				var result = Call(exoticToPrim, input, [hint]);
				// ii. If Type(result) is not Object, return result.
				if (Type(result) !== 'object') {
					return result;
				}
				// iii. Throw a TypeError exception.
				throw new TypeError('Cannot convert exotic object to primitive.');
			}
			// f. If hint is "default", set hint to "number".
			if (hint === 'default') {
				hint = 'number';
			}
			// g. Return ? OrdinaryToPrimitive(input, hint).
			return OrdinaryToPrimitive(input, hint);
		}
		// 3. Return input
		return input;
	}

	// _ESAbstract.ToString
	/* global Type, ToPrimitive */
	// 7.1.12. ToString ( argument )
	// The abstract operation ToString converts argument to a value of type String according to Table 11:
	// Table 11: ToString Conversions
	/*
	|---------------|--------------------------------------------------------|
	| Argument Type | Result                                                 |
	|---------------|--------------------------------------------------------|
	| Undefined     | Return "undefined".                                    |
	|---------------|--------------------------------------------------------|
	| Null	        | Return "null".                                         |
	|---------------|--------------------------------------------------------|
	| Boolean       | If argument is true, return "true".                    |
	|               | If argument is false, return "false".                  |
	|---------------|--------------------------------------------------------|
	| Number        | Return NumberToString(argument).                       |
	|---------------|--------------------------------------------------------|
	| String        | Return argument.                                       |
	|---------------|--------------------------------------------------------|
	| Symbol        | Throw a TypeError exception.                           |
	|---------------|--------------------------------------------------------|
	| Object        | Apply the following steps:                             |
	|               | Let primValue be ? ToPrimitive(argument, hint String). |
	|               | Return ? ToString(primValue).                          |
	|---------------|--------------------------------------------------------|
	*/
	function ToString(argument) { // eslint-disable-line no-unused-vars
		switch (Type(argument)) {
			case 'symbol':
				throw new TypeError('Cannot convert a Symbol value to a string');
			case 'object':
				var primValue = ToPrimitive(argument, String);
				return ToString(primValue); // eslint-disable-line no-unused-vars
			default:
				return String(argument);
		}
	}

	// _ESAbstract.ToPropertyKey
	/* globals ToPrimitive, Type, ToString */
	// 7.1.14. ToPropertyKey ( argument )
	function ToPropertyKey(argument) { // eslint-disable-line no-unused-vars
		// 1. Let key be ? ToPrimitive(argument, hint String).
		var key = ToPrimitive(argument, String);
		// 2. If Type(key) is Symbol, then
		if (Type(key) === 'symbol') {
			// a. Return key.
			return key;
		}
		// 3. Return ! ToString(key).
		return ToString(key);
	}

	// Object.defineProperty

	// _ESAbstract.CreateDataProperty
	// 7.3.4. CreateDataProperty ( O, P, V )
	// NOTE
	// This abstract operation creates a property whose attributes are set to the same defaults used for properties created by the ECMAScript language assignment operator.
	// Normally, the property will not already exist. If it does exist and is not configurable or if O is not extensible, [[DefineOwnProperty]] will return false.
	function CreateDataProperty(O, P, V) { // eslint-disable-line no-unused-vars
		// 1. Assert: Type(O) is Object.
		// 2. Assert: IsPropertyKey(P) is true.
		// 3. Let newDesc be the PropertyDescriptor{ [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
		var newDesc = {
			value: V,
			writable: true,
			enumerable: true,
			configurable: true
		};
		// 4. Return ? O.[[DefineOwnProperty]](P, newDesc).
		try {
			Object.defineProperty(O, P, newDesc);
			return true;
		} catch (e) {
			return false;
		}
	}

	// _ESAbstract.CreateDataPropertyOrThrow
	/* global CreateDataProperty */
	// 7.3.6. CreateDataPropertyOrThrow ( O, P, V )
	function CreateDataPropertyOrThrow(O, P, V) { // eslint-disable-line no-unused-vars
		// 1. Assert: Type(O) is Object.
		// 2. Assert: IsPropertyKey(P) is true.
		// 3. Let success be ? CreateDataProperty(O, P, V).
		var success = CreateDataProperty(O, P, V);
		// 4. If success is false, throw a TypeError exception.
		if (!success) {
			throw new TypeError('Cannot assign value `' + Object.prototype.toString.call(V) + '` to property `' + Object.prototype.toString.call(P) + '` on object `' + Object.prototype.toString.call(O) + '`');
		}
		// 5. Return success.
		return success;
	}

	// _ESAbstract.CreateMethodProperty
	// 7.3.5. CreateMethodProperty ( O, P, V )
	function CreateMethodProperty(O, P, V) { // eslint-disable-line no-unused-vars
		// 1. Assert: Type(O) is Object.
		// 2. Assert: IsPropertyKey(P) is true.
		// 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.
		var newDesc = {
			value: V,
			writable: true,
			enumerable: false,
			configurable: true
		};
		// 4. Return ? O.[[DefineOwnProperty]](P, newDesc).
		Object.defineProperty(O, P, newDesc);
	}

	// Array.prototype.find
	/* global Call, CreateMethodProperty, Get, IsCallable, ToBoolean, ToLength, ToObject, ToString */
	// 22.1.3.8 Array.prototype.find ( predicate [ , thisArg ] )
	CreateMethodProperty(Array.prototype, 'find', function find(predicate /* [ , thisArg ] */) {
		// 1. Let O be ? ToObject(this value).
		var O = ToObject(this);
		// 2. Let len be ? ToLength(? Get(O, "length")).
		var len = ToLength(Get(O, "length"));
		// 3. If IsCallable(predicate) is false, throw a TypeError exception.
		if (IsCallable(predicate) === false) {
			throw new TypeError(predicate + ' is not a function');
		}
		// 4. If thisArg is present, let T be thisArg; else let T be undefined.
		var T = arguments.length > 1 ? arguments[1] : undefined;
		// 5. Let k be 0.
		var k = 0;
		// 6. Repeat, while k < len
		while (k < len) {
			// a. Let Pk be ! ToString(k).
			var Pk = ToString(k);
			// b. Let kValue be ? Get(O, Pk).
			var kValue = Get(O, Pk);
			// c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
			var testResult = ToBoolean(Call(predicate, T, [kValue, k, O]));
			// d. If testResult is true, return kValue.
			if (testResult) {
				return kValue;
			}
			// e. Increase k by 1.
			k = k + 1;
		}
		// 7. Return undefined.
		return undefined;
	});

	// Array.prototype.some
	/* global Call, CreateMethodProperty, Get, HasProperty, IsCallable, ToBoolean, ToLength, ToObject, ToString */
	// 22.1.3.24. Array.prototype.some ( callbackfn [ , thisArg ] )
	CreateMethodProperty(Array.prototype, 'some', function some(callbackfn /* [ , thisArg ] */) {
		// 1. Let O be ? ToObject(this value).
		var O = ToObject(this);
		// 2. Let len be ? ToLength(? Get(O, "length")).
		var len = ToLength(Get(O, "length"));
		// 3. If IsCallable(callbackfn) is false, throw a TypeError exception.
		if (IsCallable(callbackfn) === false) {
			throw new TypeError(callbackfn + ' is not a function');
		}
		// 4. If thisArg is present, let T be thisArg; else let T be undefined.
		var T = arguments.length > 1 ? arguments[1] : undefined;
		// 5. Let k be 0.
		var k = 0;
		// 6. Repeat, while k < len
		while (k < len) {
			// a. Let Pk be ! ToString(k).
			var Pk = ToString(k);
			// b. Let kPresent be ? HasProperty(O, Pk).
			var kPresent = HasProperty(O, Pk);
			// c. If kPresent is true, then
			if (kPresent) {
				// i. Let kValue be ? Get(O, Pk).
				var kValue = Get(O, Pk);
				// ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).
				var testResult = ToBoolean(Call(callbackfn, T, [kValue, k, O]));
				// iii. If testResult is true, return true.
				if (testResult) {
					return true;
				}
			}
			// d. Increase k by 1.
			k = k + 1;
		}
		// 7. Return false.
		return false;
	});

	// Object.getOwnPropertyDescriptor
	/* global CreateMethodProperty, ToObject, ToPropertyKey, HasOwnProperty, Type */
	(function () {
		var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

		var supportsDOMDescriptors = (function () {
			try {
				return Object.defineProperty(document.createElement('div'), 'one', {
					get: function () {
						return 1;
					}
				}).one === 1;
			} catch (e) {
				return false;
			}
		});

		var toString = ({}).toString;
		var split = ''.split;

		// 19.1.2.8 Object.getOwnPropertyDescriptor ( O, P )
		CreateMethodProperty(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(O, P) {
			// 1. Let obj be ? ToObject(O).
			var obj = ToObject(O);
			// Polyfill.io fallback for non-array-like strings which exist in some ES3 user-agents (IE 8)
			obj = (Type(obj) === 'string' || obj instanceof String) && toString.call(O) == '[object String]' ? split.call(O, '') : Object(O);

			// 2. Let key be ? ToPropertyKey(P).
			var key = ToPropertyKey(P);

			// 3. Let desc be ? obj.[[GetOwnProperty]](key).
			// 4. Return FromPropertyDescriptor(desc).
			// Polyfill.io Internet Explorer 8 natively supports property descriptors only on DOM objects.
			// We will fallback to the polyfill implementation if the native implementation throws an error.
			if (supportsDOMDescriptors) {
				try {
					return nativeGetOwnPropertyDescriptor(obj, key);
					// eslint-disable-next-line no-empty
				} catch (error) { }
			}
			if (HasOwnProperty(obj, key)) {
				return {
					enumerable: true,
					configurable: true,
					writable: true,
					value: obj[key]
				};
			}
		});
	}());

	// Object.getPrototypeOf
	/* global CreateMethodProperty */
	// Based on: https://github.com/es-shims/es5-shim/blob/master/es5-sham.js

	// https://github.com/es-shims/es5-shim/issues#issue/2
	// http://ejohn.org/blog/objectgetprototypeof/
	// recommended by fschaefer on github
	//
	// sure, and webreflection says ^_^
	// ... this will nerever possibly return null
	// ... Opera Mini breaks here with infinite loops
	CreateMethodProperty(Object, 'getPrototypeOf', function getPrototypeOf(object) {
		if (object !== Object(object)) {
			throw new TypeError('Object.getPrototypeOf called on non-object');
		}
		var proto = object.__proto__;
		if (proto || proto === null) {
			return proto;
		} else if (typeof object.constructor == 'function' && object instanceof object.constructor) {
			return object.constructor.prototype;
		} else if (object instanceof Object) {
			return Object.prototype;
		} else {
			// Correctly return null for Objects created with `Object.create(null)`
			// (shammed or native) or `{ __proto__: null}`.  Also returns null for
			// cross-realm objects on browsers that lack `__proto__` support (like
			// IE <11), but that's the best we can do.
			return null;
		}
	});

	// Object.keys
	/* global CreateMethodProperty */
	CreateMethodProperty(Object, "keys", (function () {
		'use strict';

		// modified from https://github.com/es-shims/object-keys

		var has = Object.prototype.hasOwnProperty;
		var toStr = Object.prototype.toString;
		var isEnumerable = Object.prototype.propertyIsEnumerable;
		var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
		var hasPrototypeEnumBug = isEnumerable.call(function () { }, 'prototype');
		function hasProtoEnumBug() {
			// Object.create polyfill creates an enumerable __proto__
			var createdObj;
			try {
				createdObj = Object.create({});
			} catch (e) {
				// If this fails the polyfil isn't loaded yet, but will be.
				// Can't add it to depedencies because of it would create a circular depedency.
				return true;
			}

			return isEnumerable.call(createdObj, '__proto__')
		}

		var dontEnums = [
			'toString',
			'toLocaleString',
			'valueOf',
			'hasOwnProperty',
			'isPrototypeOf',
			'propertyIsEnumerable',
			'constructor'
		];
		var equalsConstructorPrototype = function (o) {
			var ctor = o.constructor;
			return ctor && ctor.prototype === o;
		};
		var excludedKeys = {
			$console: true,
			$external: true,
			$frame: true,
			$frameElement: true,
			$frames: true,
			$innerHeight: true,
			$innerWidth: true,
			$outerHeight: true,
			$outerWidth: true,
			$pageXOffset: true,
			$pageYOffset: true,
			$parent: true,
			$scrollLeft: true,
			$scrollTop: true,
			$scrollX: true,
			$scrollY: true,
			$self: true,
			$webkitIndexedDB: true,
			$webkitStorageInfo: true,
			$window: true
		};
		var hasAutomationEqualityBug = (function () {
			if (typeof window === 'undefined') { return false; }
			for (var k in window) {
				try {
					if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
						try {
							equalsConstructorPrototype(window[k]);
						} catch (e) {
							return true;
						}
					}
				} catch (e) {
					return true;
				}
			}
			return false;
		}());
		var equalsConstructorPrototypeIfNotBuggy = function (o) {
			if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
				return equalsConstructorPrototype(o);
			}
			try {
				return equalsConstructorPrototype(o);
			} catch (e) {
				return false;
			}
		};

		function isArgumentsObject(value) {
			var str = toStr.call(value);
			var isArgs = str === '[object Arguments]';
			if (!isArgs) {
				isArgs = str !== '[object Array]' &&
					value !== null &&
					typeof value === 'object' &&
					typeof value.length === 'number' &&
					value.length >= 0 &&
					toStr.call(value.callee) === '[object Function]';
			}
			return isArgs;
		}

		return function keys(object) {
			var isFunction = toStr.call(object) === '[object Function]';
			var isArguments = isArgumentsObject(object);
			var isString = toStr.call(object) === '[object String]';
			var theKeys = [];

			if (object === undefined || object === null) {
				throw new TypeError('Cannot convert undefined or null to object');
			}

			var skipPrototype = hasPrototypeEnumBug && isFunction;
			if (isString && object.length > 0 && !has.call(object, 0)) {
				for (var i = 0; i < object.length; ++i) {
					theKeys.push(String(i));
				}
			}

			if (isArguments && object.length > 0) {
				for (var j = 0; j < object.length; ++j) {
					theKeys.push(String(j));
				}
			} else {
				for (var name in object) {
					if (!(hasProtoEnumBug() && name === '__proto__') && !(skipPrototype && name === 'prototype') && has.call(object, name)) {
						theKeys.push(String(name));
					}
				}
			}

			if (hasDontEnumBug) {
				var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

				for (var k = 0; k < dontEnums.length; ++k) {
					if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
						theKeys.push(dontEnums[k]);
					}
				}
			}
			return theKeys;
		};
	}()));

	// Object.defineProperties
	/* global CreateMethodProperty, Get, ToObject, Type */
	// 19.1.2.3. Object.defineProperties ( O, Properties )
	CreateMethodProperty(Object, 'defineProperties', function defineProperties(O, Properties) {
		// 1. If Type(O) is not Object, throw a TypeError exception.
		if (Type(O) !== 'object') {
			throw new TypeError('Object.defineProperties called on non-object');
		}
		// 2. Let props be ? ToObject(Properties).
		var props = ToObject(Properties);
		// 3. Let keys be ? props.[[OwnPropertyKeys]]().
		/*
			Polyfill.io - This step in our polyfill is not complying with the specification.
			[[OwnPropertyKeys]] is meant to return ALL keys, including non-enumerable and symbols.
			TODO: When we have Reflect.ownKeys, use that instead as it is the userland equivalent of [[OwnPropertyKeys]].
		*/
		var keys = Object.keys(props);
		// 4. Let descriptors be a new empty List.
		var descriptors = [];
		// 5. For each element nextKey of keys in List order, do
		for (var i = 0; i < keys.length; i++) {
			var nextKey = keys[i];
			// a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).
			var propDesc = Object.getOwnPropertyDescriptor(props, nextKey);
			// b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then
			if (propDesc !== undefined && propDesc.enumerable) {
				// i. Let descObj be ? Get(props, nextKey).
				var descObj = Get(props, nextKey);
				// ii. Let desc be ? ToPropertyDescriptor(descObj).
				// Polyfill.io - We skip this step because Object.defineProperty deals with it.
				// TODO: Implement this step?
				var desc = descObj;
				// iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.
				descriptors.push([nextKey, desc]);
			}
		}
		// 6. For each pair from descriptors in list order, do
		for (var j = 0; j < descriptors.length; j++) {
			// a. Let P be the first element of pair.
			var P = descriptors[j][0];
			// b. Let desc be the second element of pair.
			desc = descriptors[j][1];
			// c. Perform ? DefinePropertyOrThrow(O, P, desc).
			Object.defineProperty(O, P, desc);
		}
		// 7. Return O.
		return O;
	});


	// _ESAbstract.OrdinaryCreateFromConstructor
	/* global GetPrototypeFromConstructor */
	// 9.1.13. OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )
	function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) { // eslint-disable-line no-unused-vars
		var internalSlotsList = arguments[2] || {};
		// 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object.
		// The corresponding object must be an intrinsic that is intended to be used as the[[Prototype]] value of an object.

		// 2. Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).
		var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);

		// 3. Return ObjectCreate(proto, internalSlotsList).
		// Polyfill.io - We do not pass internalSlotsList to Object.create because Object.create does not use the default ordinary object definitions specified in 9.1.
		var obj = Object.create(proto);
		for (var name in internalSlotsList) {
			if (Object.prototype.hasOwnProperty.call(internalSlotsList, name)) {
				Object.defineProperty(obj, name, {
					configurable: true,
					enumerable: false,
					writable: true,
					value: internalSlotsList[name]
				});
			}
		}
		return obj;
	}

	// _ESAbstract.Construct
	/* global IsConstructor, OrdinaryCreateFromConstructor, Call */
	// 7.3.13. Construct ( F [ , argumentsList [ , newTarget ]] )
	function Construct(F /* [ , argumentsList [ , newTarget ]] */) { // eslint-disable-line no-unused-vars
		// 1. If newTarget is not present, set newTarget to F.
		var newTarget = arguments.length > 2 ? arguments[2] : F;

		// 2. If argumentsList is not present, set argumentsList to a new empty List.
		var argumentsList = arguments.length > 1 ? arguments[1] : [];

		// 3. Assert: IsConstructor(F) is true.
		if (!IsConstructor(F)) {
			throw new TypeError('F must be a constructor.');
		}

		// 4. Assert: IsConstructor(newTarget) is true.
		if (!IsConstructor(newTarget)) {
			throw new TypeError('newTarget must be a constructor.');
		}

		// 5. Return ? F.[[Construct]](argumentsList, newTarget).
		// Polyfill.io - If newTarget is the same as F, it is equivalent to new F(...argumentsList).
		if (newTarget === F) {
			return new (Function.prototype.bind.apply(F, [null].concat(argumentsList)))();
		} else {
			// Polyfill.io - This is mimicking section 9.2.2 step 5.a.
			var obj = OrdinaryCreateFromConstructor(newTarget, Object.prototype);
			return Call(F, obj, argumentsList);
		}
	}

	// _ESAbstract.ArraySpeciesCreate
	/* global IsArray, ArrayCreate, Get, Type, IsConstructor, Construct */
	// 9.4.2.3. ArraySpeciesCreate ( originalArray, length )
	function ArraySpeciesCreate(originalArray, length) { // eslint-disable-line no-unused-vars
		// 1. Assert: length is an integer Number ≥ 0.
		// 2. If length is -0, set length to +0.
		if (length === 0 && 1 / length === -Infinity) {
			length = 0;
		}

		// 3. Let isArray be ? IsArray(originalArray).
		var isArray = IsArray(originalArray);

		// 4. If isArray is false, return ? ArrayCreate(length).
		if (isArray === false) {
			return ArrayCreate(length);
		}

		// 5. Let C be ? Get(originalArray, "constructor").
		var C = Get(originalArray, 'constructor');

		// Polyfill.io - We skip this section as not sure how to make a cross-realm normal Array, a same-realm Array.
		// 6. If IsConstructor(C) is true, then
		// if (IsConstructor(C)) {
		// a. Let thisRealm be the current Realm Record.
		// b. Let realmC be ? GetFunctionRealm(C).
		// c. If thisRealm and realmC are not the same Realm Record, then
		// i. If SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, set C to undefined.
		// }
		// 7. If Type(C) is Object, then
		if (Type(C) === 'object') {
			// a. Set C to ? Get(C, @@species).
			C = 'Symbol' in self && 'species' in self.Symbol ? Get(C, self.Symbol.species) : undefined;
			// b. If C is null, set C to undefined.
			if (C === null) {
				C = undefined;
			}
		}
		// 8. If C is undefined, return ? ArrayCreate(length).
		if (C === undefined) {
			return ArrayCreate(length);
		}
		// 9. If IsConstructor(C) is false, throw a TypeError exception.
		if (!IsConstructor(C)) {
			throw new TypeError('C must be a constructor');
		}
		// 10. Return ? Construct(C, « length »).
		return Construct(C, [length]);
	}

	// Array.prototype.filter
	/* global CreateMethodProperty, ToObject, ToLength, Get, IsCallable, ArraySpeciesCreate, ToString, HasProperty, ToBoolean, Call, CreateDataPropertyOrThrow */
	// 22.1.3.7. Array.prototype.filter ( callbackfn [ , thisArg ] )
	CreateMethodProperty(Array.prototype, 'filter', function filter(callbackfn /* [ , thisArg ] */) {
		// 1. Let O be ? ToObject(this value).
		var O = ToObject(this);
		// 2. Let len be ? ToLength(? Get(O, "length")).
		var len = ToLength(Get(O, "length"));
		// 3. If IsCallable(callbackfn) is false, throw a TypeError exception.
		if (IsCallable(callbackfn) === false) {
			throw new TypeError(callbackfn + ' is not a function');
		}
		// 4. If thisArg is present, let T be thisArg; else let T be undefined.
		var T = arguments.length > 1 ? arguments[1] : undefined;
		// 5. Let A be ? ArraySpeciesCreate(O, 0).
		var A = ArraySpeciesCreate(O, 0);
		// 6. Let k be 0.
		var k = 0;
		// 7. Let to be 0.
		var to = 0;
		// 8. Repeat, while k < len
		while (k < len) {
			// a. Let Pk be ! ToString(k).
			var Pk = ToString(k);
			// b. Let kPresent be ? HasProperty(O, Pk).
			var kPresent = HasProperty(O, Pk);
			// c. If kPresent is true, then
			if (kPresent) {
				// i. Let kValue be ? Get(O, Pk).
				var kValue = Get(O, Pk);
				// ii. Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).
				var selected = ToBoolean(Call(callbackfn, T, [kValue, k, O]));
				// iii. If selected is true, then
				if (selected) {
					// 1. Perform ? CreateDataPropertyOrThrow(A, ! ToString(to), kValue)
					CreateDataPropertyOrThrow(A, ToString(to), kValue);
					// 2. Increase to by 1.
					to = to + 1;
				}

			}
			// d. Increase k by 1.
			k = k + 1;
		}
		// 9. Return A.
		return A;
	});

	// Array.prototype.map
	/* global ArraySpeciesCreate, Call, CreateDataPropertyOrThrow, CreateMethodProperty, Get, HasProperty, IsCallable, ToLength, ToObject, ToString */
	// 22.1.3.16. Array.prototype.map ( callbackfn [ , thisArg ] )
	CreateMethodProperty(Array.prototype, 'map', function map(callbackfn /* [ , thisArg ] */) {
		// 1. Let O be ? ToObject(this value).
		var O = ToObject(this);
		// 2. Let len be ? ToLength(? Get(O, "length")).
		var len = ToLength(Get(O, "length"));
		// 3. If IsCallable(callbackfn) is false, throw a TypeError exception.
		if (IsCallable(callbackfn) === false) {
			throw new TypeError(callbackfn + ' is not a function');
		}
		// 4. If thisArg is present, let T be thisArg; else let T be undefined.
		var T = arguments.length > 1 ? arguments[1] : undefined;
		// 5. Let A be ? ArraySpeciesCreate(O, len).
		var A = ArraySpeciesCreate(O, len);
		// 6. Let k be 0.
		var k = 0;
		// 7. Repeat, while k < len
		while (k < len) {
			// a. Let Pk be ! ToString(k).
			var Pk = ToString(k);
			// b. Let kPresent be ? HasProperty(O, Pk).
			var kPresent = HasProperty(O, Pk);
			// c. If kPresent is true, then
			if (kPresent) {
				// i. Let kValue be ? Get(O, Pk).
				var kValue = Get(O, Pk);
				// ii. Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).
				var mappedValue = Call(callbackfn, T, [kValue, k, O]);
				// iii. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).
				CreateDataPropertyOrThrow(A, Pk, mappedValue);
			}
			// d. Increase k by 1.
			k = k + 1;
		}
		// 8. Return A.
		return A;
	});

	// Array.prototype.sort
	/* global CreateMethodProperty, IsCallable */
	"use strict";

	var origSort = Array.prototype.sort;

	// 22.1.3.27 Array.prototype.sort ( comparefn )
	// The elements of this array are sorted. The sort must be stable (that is,
	// elements that compare equal must remain in their original order). If
	// comparefn is not undefined, it should be a function that accepts two
	// arguments x and y and returns a negative value
	// if x < y, zero if x = y, or a positive value if x > y.

	CreateMethodProperty(Array.prototype, "sort", function sort(compareFn) {
		// 1. If comparefn is not undefined and IsCallable(comparefn) is false, throw
		//    a TypeError exception.
		if (compareFn !== undefined && IsCallable(compareFn) === false) {
			throw new TypeError(
				"The comparison function must be either a function or undefined"
			);
		}

		// Polyfill.io - the steps below are handled by the native
		// Array.prototype.sort method that we call.
		// 2.Let obj be ? ToObject(this value).
		// 3.Let len be ? LengthOfArrayLike(obj).

		// if comprateFn does not exist, use the spec defined in-built SortCompare.
		if (compareFn === undefined) {
			origSort.call(this);
		} else {
			// if compareFn exists, sort the array, breaking sorting ties by using the
			// items' original index position.

			// Keep track of the items starting index position.
			var that = Array.prototype.map.call(this, function (item, index) {
				return { item: item, index: index };
			});
			origSort.call(that, function (a, b) {
				var compareResult = compareFn.call(undefined, a.item, b.item);
				return compareResult === 0 ? a.index - b.index : compareResult;
			});
			// update the original object (`this`) with the new position for the items
			// which were moved.
			for (var a in that) {
				if (Object.prototype.hasOwnProperty.call(that, a)) {
					if (that[a].item !== this[a]) {
						this[a] = that[a].item;
					}
				}
			}
		}

		return this;
	});

	// String.prototype.startsWith
	/* global CreateMethodProperty, IsRegExp, RequireObjectCoercible, ToInteger, ToString */
	// 21.1.3.20. String.prototype.startsWith ( searchString [ , position ] )
	CreateMethodProperty(String.prototype, 'startsWith', function startsWith(searchString /* [ , position ] */) {
		'use strict';
		var position = arguments.length > 1 ? arguments[1] : undefined;
		// 1. Let O be ? RequireObjectCoercible(this value).
		var O = RequireObjectCoercible(this);
		// 2. Let S be ? ToString(O).
		var S = ToString(O);
		// 3. Let isRegExp be ? IsRegExp(searchString).
		var isRegExp = IsRegExp(searchString);
		// 4. If isRegExp is true, throw a TypeError exception.
		if (isRegExp) {
			throw new TypeError('First argument to String.prototype.startsWith must not be a regular expression');
		}
		// 5. Let searchStr be ? ToString(searchString).
		var searchStr = ToString(searchString);
		// 6. Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)
		var pos = ToInteger(position);
		// 7. Let len be the length of S.
		var len = S.length;
		// 8. Let start be min(max(pos, 0), len).
		var start = Math.min(Math.max(pos, 0), len);
		// 9. Let searchLength be the length of searchStr.
		var searchLength = searchStr.length;
		// 10. If searchLength+start is greater than len, return false.
		if (searchLength + start > len) {
			return false;
		}
		// 11. If the sequence of elements of S starting at start of length searchLength is the same as the full element sequence of searchStr, return true.
		if (S.substr(start).indexOf(searchString) === 0) {
			return true;
		}
		// 12. Otherwise, return false.
		return false;
	});
})
	('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});